# Writing Python code to generate patterns for cellular automata based on given rules
# and to visualize the first n iterations of the patterns as black and white blocks.

import torch
import torch.nn.functional as F
import numpy as np
import wandb
from scipy.spatial import distance_matrix
import matplotlib.pyplot as plt

def generate_pattern(rule_number, size, iterations):
    """
    Generates cellular automata patterns based on a specified rule.
    
    Parameters:
        rule_number (int): Rule number (0-255) defining the automata.
        size (int): Size of the block series.
        iterations (int): Number of iterations to compute.
    
    Returns:
        np.ndarray: Matrix of dimension (iterations x size) with pattern.
    """
    # Parse rule number into binary representation for rules
    rule_binary = np.array([int(x) for x in f"{rule_number:08b}"[::-1]])
    # Rules based on binary representation:
    # 111 -> rule_binary[7], 110 -> rule_binary[6], ..., 000 -> rule_binary[0]
    
    # Initialize the block series
    pattern = np.zeros((iterations, size), dtype=int)
    # pattern[0, 0] = 1  # Initial series starts with 1, followed by 0s
    pattern[0, :] = np.random.randint(0, 2, size=size)  # Randomly assign 0 or 1 to each block

    
    for t in range(1, iterations):
        for i in range(size):
            # Determine neighborhood as circular
            left = pattern[t-1, (i-1) % size]
            center = pattern[t-1, i]
            right = pattern[t-1, (i+1) % size]
            # Determine the rule index
            rule_index = 7 - (4 * left + 2 * center + right)
            pattern[t, i] = rule_binary[rule_index]
    
    return pattern

def visualize_pattern(pattern, n):
    """
    Visualizes the first n iterations of the cellular automata pattern.
    
    Parameters:
        pattern (np.ndarray): Pattern matrix generated by `generate_pattern`.
        n (int): Number of iterations to visualize.
    """
    plt.figure(figsize=(10, n / 2))
    plt.imshow(pattern[:n], cmap="binary", interpolation="nearest")
    plt.axis("off")
    plt.show()
    
def get_batch_ca(rule_number, num_samples=100, seq_size=30):
    """
    Generates a batch of data for the cellular automata task, where each sample 
    has a randomly initialized input and its corresponding output is calculated
    using the given rule.

    Parameters:
        rule_number (int): The rule number (0-255) defining the automaton.
        num_samples (int): Number of samples (sequences) in the batch.
        seq_size (int): Size of the block series (sequence length).

    Returns:
        Tuple: (inputs, targets) both of shape (num_samples, size).
    """
    inputs = np.zeros((num_samples, seq_size), dtype=int)   # Random inputs
    targets = np.zeros((num_samples, seq_size), dtype=int)  # Corresponding outputs

    for i in range(num_samples):
        # Randomly initialize a single row for the input
        inputs[i] = np.random.randint(0, 2, size=seq_size)
        
        # Use the generate_pattern function to calculate the output (1 iteration)
        targets[i] = generate_pattern(rule_number, seq_size, iterations=2)[1]  # Take the second row

    # return inputs, targets
    return torch.tensor(inputs, dtype=torch.float32).permute(1, 0), torch.tensor(targets, dtype=torch.int64).permute(1, 0)



# # Example usage:
# rule = 30  # Example: Rule 30
# size = 200  # Size of block series
# iterations = 100  # Number of iterations
# pattern = generate_pattern(rule, size, iterations)

# # Visualize the first 20 iterations
# visualize_pattern(pattern, 50)
